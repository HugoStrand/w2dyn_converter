import numpy as np
import os, sys

### add main directory of w2dyn installation
home = os.path.expanduser("~")
auxdir=home+"/w2dynamics_github"
sys.path.insert(0,auxdir)

### here come the necessary imports form w2dyn dmft loop
import dmft.impurity as impurity
import auxiliaries.config as config

### import converter triqs --> numpy, and a function that generates a test-impurity
import example as example

### read w2dyn parameter file; later we will replace this by a 
### converter of triqs-parameters to w2dyn-parameters
cfg_file_name="Parameters.in"
key_value_args={}
cfg =  config.get_cfg(cfg_file_name, key_value_args, err=sys.stderr)

#print "cfg", cfg
#exit(-1)

### initialize the solver; it needs the config-string
Nseed = 1
use_mpi = False
mpi_comm = None
solver = impurity.CtHybSolver(cfg, Nseed, 0,0,0, not use_mpi, mpi_comm)

### generate input from triqs converter
nbands, beta, nftau, muimp, u_matrix, ftau = example.generate_testimpurity_with_triqs(2, 200, 10)   # input: norb, nftau, beta

print " "
print "...................................................."
print "objects generated by the triqs converter:"

print "nbands         ", nbands
print "beta           ", beta
print "nftau          ", nftau
print "muimp          ", muimp.shape
print "u_matrix       ", u_matrix.shape
print "ftau           ", ftau.shape

### generate dummy input that we don't necessarily need
niw     = 2*cfg["QMC"]["Niw"]
g0inviw = np.zeros(shape=(niw, nbands, 2, nbands, 2))
fiw     = np.zeros(shape=(niw, nbands, 2, nbands, 2))
fmom    = np.zeros(shape=(2, nbands, 2, nbands, 2))
symmetry_moves = ()
paramag = False
atom = config.atomlist_from_cfg(cfg, nbands)[0]

print " "
print "...................................................."
print "objects needed as dummies (for now):"
print "niw            ", niw
print "g0inviw        ", g0inviw.shape
print "fiw            ", fiw.shape
print "fmom           ", fmom.shape
print "symmetry_moves ", symmetry_moves
print "paramag        ", paramag
print "atom           ", atom

### we begin with real not complex calculations
g0inviw = np.real(g0inviw)
fiw = np.real(fiw)
fmom = np.real(fmom)
ftau = np.real(ftau)
muimp = np.real(muimp)

### here the properties of the impurity will be defined
imp_problem = impurity.ImpurityProblem(
                beta, g0inviw, fiw, fmom, ftau,
                muimp, atom.dd_int, None, None, symmetry_moves,
                paramag)

print " "
print "...................................................."
### feed impurity problem into solver
solver.set_problem(imp_problem)

### solve impurity problem 
mccfgcontainer = []
iter_no = 1
result = solver.solve(iter_no, mccfgcontainer)

### look through the results list and find G(tau)
#for qtty_name, qtty_value in result.other.iteritems():
    ##print "qtty_name", qtty_name
    #if qtty_name == "gtau": 
        #gtau = qtty_value

### read out the G(tau)
gtau = result.other["gtau"]

print " "
print "...................................................."
print "gtau.shape", gtau.shape

### save G(tau)
np.savetxt("gtau_00.dat", gtau[0,0,:])
np.savetxt("gtau_01.dat", gtau[0,1,:])
np.savetxt("gtau_10.dat", gtau[1,0,:])
np.savetxt("gtau_11.dat", gtau[1,1,:])
